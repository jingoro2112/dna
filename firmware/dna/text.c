/*------------------------------------------------------------------------------
 * Copyright: (c) 2013 by Curt Hartung avr@northarc.com
 * This work is released under the Creating Commons 3.0 license
 * found at http://creativecommons.org/licenses/by-nc-sa/3.0/legalcode
 * and in the LICENCE.txt file included with this distribution
 */

#include "text.h"
#include "frame.h"
#include "dna.h"
#include "24c512.h"

#include "../oled/eeprom_image.h"

#include <avr/pgmspace.h>

//------------------------------------------------------------------------------
// non-scaled 7x7 with -1 pre and post
const PROGMEM unsigned char c_vt100_7[658]=
{
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x00, 0x08, 0x00, 0x14, 0x14, 
	0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x3E, 0x14, 0x3E, 0x14, 0x00, 0x00, 0x1C, 0x0A, 0x1C, 
	0x28, 0x1C, 0x00, 0x02, 0x12, 0x08, 0x04, 0x12, 0x10, 0x00, 0x00, 0x04, 0x0A, 0x04, 0x0A, 0x14, 
	0x00, 0x0C, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x08, 0x04, 0x04, 0x04, 0x04, 0x08, 0x00, 0x04, 
	0x08, 0x08, 0x08, 0x08, 0x04, 0x00, 0x00, 0x0A, 0x04, 0x0E, 0x04, 0x0A, 0x00, 0x00, 0x08, 0x08, 
	0x3E, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x04, 0x02, 0x00, 0x00, 0x00, 0x1E, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x10, 0x08, 0x04, 0x02, 0x00, 0x00, 
	0x04, 0x0A, 0x0A, 0x0A, 0x0A, 0x04, 0x00, 0x04, 0x06, 0x04, 0x04, 0x04, 0x0E, 0x00, 0x0C, 0x12, 
	0x10, 0x08, 0x04, 0x1E, 0x00, 0x1E, 0x10, 0x0C, 0x10, 0x12, 0x0C, 0x00, 0x08, 0x0C, 0x0A, 0x1E, 
	0x08, 0x08, 0x00, 0x1E, 0x02, 0x0E, 0x10, 0x12, 0x0C, 0x00, 0x0C, 0x02, 0x0E, 0x12, 0x12, 0x0C, 
	0x00, 0x1E, 0x10, 0x08, 0x08, 0x04, 0x04, 0x00, 0x0C, 0x12, 0x0C, 0x12, 0x12, 0x0C, 0x00, 0x0C, 
	0x12, 0x12, 0x1C, 0x10, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 
	0x00, 0x0C, 0x04, 0x02, 0x00, 0x08, 0x04, 0x02, 0x04, 0x08, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x1E, 
	0x00, 0x00, 0x00, 0x02, 0x04, 0x08, 0x04, 0x02, 0x00, 0x04, 0x0A, 0x08, 0x04, 0x00, 0x04, 0x00, 
	0x0C, 0x12, 0x1A, 0x1A, 0x02, 0x0C, 0x00, 0x0C, 0x12, 0x12, 0x1E, 0x12, 0x12, 0x00, 0x0E, 0x12, 
	0x0E, 0x12, 0x12, 0x0E, 0x00, 0x0C, 0x12, 0x02, 0x02, 0x12, 0x0C, 0x00, 0x0E, 0x12, 0x12, 0x12, 
	0x12, 0x0E, 0x00, 0x1E, 0x02, 0x0E, 0x02, 0x02, 0x1E, 0x00, 0x1E, 0x02, 0x0E, 0x02, 0x02, 0x02, 
	0x00, 0x0C, 0x12, 0x02, 0x1A, 0x12, 0x1C, 0x00, 0x12, 0x12, 0x1E, 0x12, 0x12, 0x12, 0x00, 0x0E, 
	0x04, 0x04, 0x04, 0x04, 0x0E, 0x00, 0x10, 0x10, 0x10, 0x10, 0x12, 0x0C, 0x00, 0x12, 0x0A, 0x06, 
	0x06, 0x0A, 0x12, 0x00, 0x02, 0x02, 0x02, 0x02, 0x02, 0x1E, 0x00, 0x12, 0x1E, 0x1E, 0x12, 0x12, 
	0x12, 0x00, 0x12, 0x16, 0x16, 0x1A, 0x1A, 0x12, 0x00, 0x0C, 0x12, 0x12, 0x12, 0x12, 0x0C, 0x00, 
	0x0E, 0x12, 0x12, 0x0E, 0x02, 0x02, 0x00, 0x0C, 0x12, 0x12, 0x12, 0x16, 0x0C, 0x10, 0x0E, 0x12, 
	0x12, 0x0E, 0x0A, 0x12, 0x00, 0x0C, 0x12, 0x04, 0x08, 0x12, 0x0C, 0x00, 0x0E, 0x04, 0x04, 0x04, 
	0x04, 0x04, 0x00, 0x12, 0x12, 0x12, 0x12, 0x12, 0x0C, 0x00, 0x12, 0x12, 0x12, 0x12, 0x0C, 0x0C, 
	0x00, 0x12, 0x12, 0x12, 0x1E, 0x1E, 0x12, 0x00, 0x12, 0x12, 0x0C, 0x0C, 0x12, 0x12, 0x00, 0x0A, 
	0x0A, 0x0A, 0x04, 0x04, 0x04, 0x00, 0x1E, 0x10, 0x08, 0x04, 0x02, 0x1E, 0x00, 0x0E, 0x02, 0x02, 
	0x02, 0x02, 0x0E, 0x00, 0x00, 0x02, 0x04, 0x08, 0x10, 0x00, 0x00, 0x0E, 0x08, 0x08, 0x08, 0x08, 
	0x0E, 0x00, 0x04, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x00, 
	0x06, 0x04, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x12, 0x1A, 0x14, 0x00, 0x02, 0x02, 
	0x0E, 0x12, 0x12, 0x0E, 0x00, 0x00, 0x00, 0x0C, 0x02, 0x02, 0x0C, 0x00, 0x10, 0x10, 0x1C, 0x12, 
	0x12, 0x1C, 0x00, 0x00, 0x00, 0x0C, 0x1A, 0x06, 0x0C, 0x00, 0x08, 0x14, 0x04, 0x0E, 0x04, 0x04, 
	0x00, 0x00, 0x00, 0x1C, 0x12, 0x0C, 0x02, 0x1C, 0x02, 0x02, 0x0E, 0x12, 0x12, 0x12, 0x00, 0x04, 
	0x00, 0x06, 0x04, 0x04, 0x0E, 0x00, 0x08, 0x00, 0x08, 0x08, 0x08, 0x0A, 0x04, 0x02, 0x02, 0x0A, 
	0x06, 0x0A, 0x12, 0x00, 0x06, 0x04, 0x04, 0x04, 0x04, 0x0E, 0x00, 0x00, 0x00, 0x0A, 0x1E, 0x12, 
	0x12, 0x00, 0x00, 0x00, 0x0E, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x0C, 0x12, 0x12, 0x0C, 0x00, 
	0x00, 0x00, 0x0E, 0x12, 0x12, 0x0E, 0x02, 0x00, 0x00, 0x1C, 0x12, 0x12, 0x1C, 0x10, 0x00, 0x00, 
	0x0E, 0x12, 0x02, 0x02, 0x00, 0x00, 0x00, 0x1C, 0x06, 0x18, 0x0E, 0x00, 0x04, 0x04, 0x0E, 0x04, 
	0x04, 0x18, 0x00, 0x00, 0x00, 0x12, 0x12, 0x12, 0x1C, 0x00, 0x00, 0x00, 0x0A, 0x0A, 0x0A, 0x04, 
	0x00, 0x00, 0x00, 0x12, 0x12, 0x1E, 0x1E, 0x00, 0x00, 0x00, 0x12, 0x0C, 0x0C, 0x12, 0x00, 0x00, 
	0x00, 0x12, 0x12, 0x14, 0x08, 0x04, 0x00, 0x00, 0x1E, 0x08, 0x04, 0x1E, 0x00, 0x08, 0x04, 0x06, 
	0x04, 0x04, 0x08, 0x00, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x02, 0x04, 0x0C, 0x04, 0x04, 
	0x02, 0x00, 
};

//------------------------------------------------------------------------------
// use the vt100 7-point font built in above
void stringAtResidentEx( char flash, char* string, char x, char y )
{
	char c;
	while( (c = flash ? pgm_read_byte(string++) : *string++) )
	{
		unsigned int character = (unsigned int)(c - 32) * 0x0007;

		x--;

		unsigned char pos = 0;
		unsigned char byte = 0;

		for( unsigned char h=0; h<0x7; h++ )
		{
			unsigned char bit = 0;
			for( unsigned char w = 0; w<0x7; w++ )
			{
				if ( bit == 0 )
				{
					byte = pgm_read_byte( c_vt100_7 + character + pos++ );
				}

				if ( 1<<bit & byte )
				{
					frameSetPixel( x + w, y + h );
				}

				if ( ++bit == 8 )
				{
					bit = 0;
				}
			}
		}

		x += 0x6;
	}
}

//------------------------------------------------------------------------------
char stringAtEx( char flash, char* string, char x, char y, unsigned char font, unsigned char dither, unsigned char lenOnly )
{
	char c;
	while( (c = flash ? pgm_read_byte(string++) : *string++) )
	{
		// find the FontCharEntry descriptor offset for this character
		unsigned int offset = (c - 32) * sizeof(struct FontCharEntry) * numberOfFonts;
		offset += (sizeof(struct FontCharEntry) * (unsigned int)font) + 1;

		// and load it in from EEPROM
		struct FontCharEntry entry;
		read24c512( 0xA0, offset, (unsigned char*)&entry, sizeof(struct FontCharEntry) );

		x += entry.pre; // pre-increment value

		if ( !lenOnly )
		{
			unsigned char pos = 0;
			unsigned char byte;

			for( unsigned char h=0; h<entry.h; h++ )
			{
				unsigned char bit = 0;
				for( unsigned char w = 0; w<entry.w; w++ )
				{
					if ( bit == 0 )
					{
						read24c512( 0xA0, entry.dataOffset + dataBlockOrigin + pos++, &byte, 1 );
					}

					if ( 1<<bit & byte )
					{
						char x1 = x + w;
						char y1 = y + h;
						if ( !dither || (dither && (x1 & 0x1) ^ (y1 & 0x1)) )
						{
							frameSetPixel( x1, y1 );
						}
					}

					if ( ++bit == 8 )
					{
						bit = 0;
					}
				}

			}
		}

		x += entry.post + entry.w; // next character position
	}

	return x;
}

//------------------------------------------------------------------------------
char* EEPROMString( unsigned int index )
{
	static char buf[MAX_EEPROM_STRLEN + 2];
	read24c512( 0xA0, index, (unsigned char *)buf, MAX_EEPROM_STRLEN + 1 );
	buf[MAX_EEPROM_STRLEN + 1] = 0; // enforce termination
	return buf;
}
