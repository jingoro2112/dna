#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>

#include "font.hpp"
#include "../util/str.hpp"

bool parseInfile( Cstr const& in, Cstr &out );

//------------------------------------------------------------------------------
int usage()
{
	printf( "Usage: fonttable <font1> <font2> <...>\n" );
	return -1;
}

//------------------------------------------------------------------------------
struct FontCharEntry
{
	unsigned short dataOffset;
	unsigned char w;
	unsigned char h;
	unsigned char pre;
	unsigned char post;
};

//------------------------------------------------------------------------------
struct FontTable
{
	FontCharEntry entry[16];
};

//------------------------------------------------------------------------------
int main( int argn, char *argv[] )
{
	Cstr out;
	char binout[65635];
	int binoutPos = 0;
	FontTable ftable[256];
	Cstr dataTable;
	Font font;
	int currentDataBlockPointer = 0;

	for( int i=0; i<(argn - 1); i++ )
	{
		if ( !font.load(argv[i+1]) )
		{
			printf( "unable to load font [%s], aborting\n", argv[i+1] );
			return false;
		}
		else
		{
			printf( "loaded font [%s]\n", argv[i+1] );
		}

		for( unsigned char g = 0x20; g<0x7E; g++ )
		{
			Font::Metrics const& metrics = font.getMetrics()[ (unsigned char)font.glyphFromChar(g) ];

//			printf( "'%c':0x%02X %d %d %d %d %d %d\n", g, (char)font.glyphFromChar(g),
//					metrics.w, metrics.h, metrics.x, metrics.y, metrics.pre, metrics.post );

			int w,h;
			const unsigned char *bmp = font.getBitmap( w, h );

			ftable[g].entry[i].dataOffset = currentDataBlockPointer;
			ftable[g].entry[i].w = metrics.w;
			ftable[g].entry[i].h = metrics.h;
			ftable[g].entry[i].pre = metrics.pre;
			ftable[g].entry[i].post = metrics.post;
			
			unsigned char byte;
			unsigned char accum;

			for( int r = metrics.y; r < (metrics.y + metrics.h); r++ )
			{
				byte = 0;
				accum = 0;

				for( int c = metrics.x; c < metrics.x + metrics.w; c++ )
				{
					if ( bmp[ (r * w) + c ] )
					{
						byte |= (1 << (7 - accum));
					}

					if (++accum == 8)
					{
						byte = 0;
						accum = 0;

						dataTable.append( byte );
						currentDataBlockPointer++;
					}
				}

				if ( accum )
				{
					dataTable.append( byte );
					currentDataBlockPointer++;
				}
			}
		}
	}

	out.format( "#ifndef FONT_LOADER_H\n"
				"#define FONT_LOADER_H\n\n"
				"/*------------------------------------------------------------------------------*\n"
				"* Copyright: (c) 2013 by Curt Hartung avr@northarc.com\n"
				"* This work is released under the Creating Commons 3.0 license\n"
				"* found at http://creativecommons.org/licenses/by-nc-sa/3.0/legalcode\n"
				"* and in the LICENCE.txt file included with this distribution\n"
				"*/\n"
				"\n"
				"//******************************************************************************\n"
				"//******************************************************************************\n"
				"//********* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT DIRECTLY *********\n"
				"//******************************************************************************\n"
				"//******************************************************************************\n"
				"\n" );

	out.appendFormat( "#define NUMBER_OF_FONTS %d\n", argn-1 );
	out.append( "/*\n" );
	out.append( "const unsigned char c_lookupTable[]=\n{\n" );

	for( unsigned char g = 0x20; g<0x7E; g++ )
	{
		for( int i=0; i<(argn - 1); i++ )
		{
			out.appendFormat( "\t0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X,\n",
							  (unsigned char)(ftable[g].entry[i].dataOffset),
							  (unsigned char)(ftable[g].entry[i].dataOffset>>8),
							  (unsigned char)ftable[g].entry[i].w,
							  (unsigned char)ftable[g].entry[i].h,
							  (unsigned char)ftable[g].entry[i].pre,
							  (unsigned char)ftable[g].entry[i].post );

			*(unsigned short *)(binout + binoutPos) = ftable[g].entry[i].dataOffset + ((6 * 95) * (argn - 1));
			binoutPos += 2;
			binout[binoutPos++] = ftable[g].entry[i].w;
			binout[binoutPos++] = ftable[g].entry[i].h;
			binout[binoutPos++] = ftable[g].entry[i].pre;
			binout[binoutPos++] = ftable[g].entry[i].post;
		}		
	}

	out.appendFormat( "};\n\n"
					  "*/\n"
					  "#define DATA_BLOCK_SIZE %d\n"
					  "/*\n"
					  "const unsigned char c_dataBlock[]=\n{", currentDataBlockPointer );
	for( int i=0; i<currentDataBlockPointer; i++ )
	{
		if ( !(i%16) )
		{
			out.append( "\n\t" );
		}

		out.appendFormat( "0x%02X, ", (unsigned char)dataTable[i] );
		binout[binoutPos++] = (unsigned char)dataTable[i];
	}
	
	out.append( "\n};\n*/\n#endif\n" );

	if ( !out.bufferToFile("font_loader.h") )
	{
		printf( "Could not save font_loader.h\n" );
		return usage();
	}

	out.setString( binout, binoutPos );
	if ( !out.bufferToFile("font_loader.bin") )
	{
		printf( "Could not save font_loader.bin\n" );
		return usage();
	}

	return 0;
}

