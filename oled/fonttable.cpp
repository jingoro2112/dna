#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>

#include "font.hpp"
#include "../util/str.hpp"

bool parseInfile( Cstr const& in, Cstr &out );

//------------------------------------------------------------------------------
int usage()
{
	printf( "Usage: fonttable <font1> <font2> <...>\n" );
	return -1;
}

//------------------------------------------------------------------------------
struct FontCharEntry
{
	unsigned short dataOffset;
	unsigned char w;
	unsigned char h;
	unsigned char pre;
	unsigned char post;
};

//------------------------------------------------------------------------------
struct FontTable
{
	FontCharEntry entry[16];
};

//------------------------------------------------------------------------------
int main( int argn, char *argv[] )
{
	Cstr out;
	char binout[65635];
	int binoutPos = 0;
	FontTable ftable[256];
	Cstr dataTable;
	Font font;
	int currentDataBlockPointer = 0;

	for( int i=0; i<(argn - 1); i++ )
	{
		Cstr convertCommand;
		convertCommand.format( "convert %s.png  -background black -flatten +matte -depth 8 %s.gray", argv[i+1], argv[i+1] );
		system( convertCommand );
		
		if ( !font.load(argv[i+1]) )
		{
			printf( "unable to load font [%s], aborting\n", argv[i+1] );
			return false;
		}
		else
		{
			printf( "loaded font [%s]\n", argv[i+1] );
		}

		for( unsigned char g = 0x20; g<0x7E; g++ )
		{
			Font::Metrics const& metrics = font.getMetrics()[ (unsigned char)font.glyphFromChar(g) ];

//			printf( "'%c':0x%02X %d %d %d %d %d %d 0x%04X\n", g, (char)font.glyphFromChar(g),
//					metrics.w, metrics.h, metrics.x, metrics.y, metrics.pre, metrics.post,
//					currentDataBlockPointer	);

			int w,h;
			const unsigned char *bmp = font.getBitmap( w, h );

			ftable[g].entry[i].dataOffset = currentDataBlockPointer;
			ftable[g].entry[i].w = metrics.w;
			ftable[g].entry[i].h = metrics.h;
			ftable[g].entry[i].pre = metrics.pre;
			ftable[g].entry[i].post = metrics.post;
			
			unsigned char byte;
			unsigned char accum;

			for( int r = metrics.y; r < (metrics.y + metrics.h); r++ )
			{
				byte = 0;
				accum = 0;

				for( int c = metrics.x; c < metrics.x + metrics.w; c++ )
				{
					if ( bmp[ (r * w) + c ] )
					{
						byte |= 1 << accum;
//						printf( "." );
					}
					else
					{
//						printf( " " );
					}

					if ( ++accum == 8 )
					{
						dataTable.append( byte );

						byte = 0;
						accum = 0;
						currentDataBlockPointer++;
					}
				}

//				printf( "\n" );

				if ( accum )
				{
					dataTable.append( byte );
					currentDataBlockPointer++;
				}
			}
		}
	}

	out.format( "#ifndef FONT_LOADER_H\n"
				"#define FONT_LOADER_H\n\n"
				"/*------------------------------------------------------------------------------*\n"
				"* Copyright: (c) 2013 by Curt Hartung avr@northarc.com\n"
				"* This work is released under the Creating Commons 3.0 license\n"
				"* found at http://creativecommons.org/licenses/by-nc-sa/3.0/legalcode\n"
				"* and in the LICENCE.txt file included with this distribution\n"
				"*/\n"
				"\n"
				"//******************************************************************************\n"
				"//******************************************************************************\n"
				"//********* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT DIRECTLY *********\n"
				"//******************************************************************************\n"
				"//******************************************************************************\n"
				"\n"
				"//------------------------------------------------------------------------------\n"
				"struct FontCharEntry\n"
				"{\n"
				"\tuint16 dataOffset;\n"
				"\tuint8 w;\n"
				"\tuint8 h;\n"
				"\tuint8 pre;\n"
				"\tuint8 post;\n"
				"};\n"
				"\n"
			  );

	int fontMetricsTableSize = (argn - 1) * sizeof(FontCharEntry) * 95;
	int fontMetricsTableOrigin = 0;

	out.append( "#ifndef AVR\n"
				"#define PROGMEM\n"
				"#endif\n\n" );
	
	out.appendFormat( "#define NUMBER_OF_FONTS %d\n", argn - 1 );
	out.appendFormat( "#define FONT_BLOCK_SIZE %d\n", fontMetricsTableSize );
	out.appendFormat( "#define FONT_BLOCK_ORIGIN %d\n", fontMetricsTableOrigin );
	out.append( "\n" );
	
	out.appendFormat( "//------------------------------------------------------------------------------\n"
					  "const PROGMEM unsigned char c_lookupTable[%d]=\n"
					  "{\n", fontMetricsTableSize, fontMetricsTableSize );

	binout[binoutPos++] = argn - 1;
			
	for( unsigned char g = 0x20; g<0x7E; g++ )
	{
		for( int i=0; i<(argn - 1); i++ )
		{
			out.appendFormat( "\t0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X,\n",
							  (unsigned char)(ftable[g].entry[i].dataOffset),
							  (unsigned char)(ftable[g].entry[i].dataOffset>>8),
							  (unsigned char)ftable[g].entry[i].w,
							  (unsigned char)ftable[g].entry[i].h,
							  (unsigned char)ftable[g].entry[i].pre,
							  (unsigned char)ftable[g].entry[i].post );

			*(unsigned short *)(binout + binoutPos) = ftable[g].entry[i].dataOffset + ((sizeof(FontCharEntry) * 95) * (argn - 1));
			binoutPos += 2;
			binout[binoutPos++] = ftable[g].entry[i].w;
			binout[binoutPos++] = ftable[g].entry[i].h;
			binout[binoutPos++] = ftable[g].entry[i].pre;
			binout[binoutPos++] = ftable[g].entry[i].post;
		}		
	}

	out.appendFormat( "};\n\n"
					  "\n"
					  "#define DATA_BLOCK_SIZE %d\n"
					  "#define DATA_BLOCK_ORIGIN %d\n"
					  "\n"
					  "//------------------------------------------------------------------------------\n"
					  "const PROGMEM unsigned char c_dataBlock[%d]=\n"
					  "{\n", currentDataBlockPointer, fontMetricsTableSize, currentDataBlockPointer, currentDataBlockPointer );
	
	for( int i=0; i<currentDataBlockPointer; i++ )
	{
		if ( !(i%16) )
		{
			out.append( "\n\t" );
		}

		out.appendFormat( "0x%02X, ", (unsigned char)dataTable[i] );
		binout[binoutPos++] = (unsigned char)dataTable[i];
	}
	
	out.append( "\n};\n\n#endif\n" );

	if ( !out.bufferToFile("font_loader.h") )
	{
		printf( "Could not save font_loader.h\n" );
		return usage();
	}

	out.setString( binout, binoutPos );
	if ( !out.bufferToFile("font_loader.bin") )
	{
		printf( "Could not save font_loader.bin\n" );
		return usage();
	}

	return 0;
}

